<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc maxdepth="3"?>
<?asciidoc-numbered?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Implementing the User Interface&#8201;&#8212;&#8201;Task-based</title>
<date>2021-07-24</date>
</info>
<section xml:id="implementing-the-user-interfacetask-based" role="text-justify">
<title>Implementing the User Interface&#8201;&#8212;&#8201;Task-based</title>
<blockquote>
<attribution>
Marty Rubin
</attribution>
<simpara>To accomplish a difficult task, one must first make it easy.</simpara>
</blockquote>
<simpara>The essence of DDD is a lot about capturing the business process and user intent a lot more closely. In the previous chapter, we designed a set of APIs without paying a lot of attention to how those APIs would get consumed by its eventual users. In this chapter, we will design the GUI for the LC application using the <link xl:href="https://openjfx.com/">JavaFX</link><footnote><simpara><link xl:href="https://openjfx.com/">https://openjfx.com/</link></simpara></footnote> framework. As part of that, we will examine how this approach of designing APIs in isolation can cause an impedance mismatch between the producers and the consumers. We will examine the consequences of this <emphasis>impedance mismatch</emphasis> and how task-based UIs can help cope with this mismatch a lot better.</simpara>
<simpara>At the end of the chapter, you will learn how to employ DDD principles to help you build robust user experiences that are simple and intuitive. You will also learn why it may be prudent to design your backend interfaces (APIs) from the perspective of the consumer.</simpara>
<section xml:id="technical-requirements">
<title>Technical Requirements</title>
<itemizedlist>
<listitem>
<simpara>JDK 1.8+ (We have used Java 16 to compile sample sources)</simpara>
</listitem>
<listitem>
<simpara>JavaFX SDK 16 and SceneBuilder</simpara>
</listitem>
<listitem>
<simpara>Maven 3.x</simpara>
</listitem>
<listitem>
<simpara>Spring Boot 2.4.x</simpara>
</listitem>
<listitem>
<simpara>mvvmFX 1.8 (<link xl:href="https://sialcasa.github.io/mvvmFX/">https://sialcasa.github.io/mvvmFX/</link>)</simpara>
</listitem>
<listitem>
<simpara>JUnit 5.7.x (Included with spring boot)</simpara>
</listitem>
<listitem>
<simpara>TestFX (for UI testing)</simpara>
</listitem>
<listitem>
<simpara>OpenJFX Monocle (for headless UI testing)</simpara>
</listitem>
<listitem>
<simpara>Project Lombok (To reduce verbosity)</simpara>
</listitem>
</itemizedlist>
<simpara>Before we dive deep into building the GUI solution, let&#8217;s do a quick recap of where we left the APIs.</simpara>
</section>
<section xml:id="api-styles">
<title>API Styles</title>
<simpara>If you recall from chapter 5, we created the following commands:</simpara>
<figure role="text-center">
<title>Commands from the event storming session</title>
<mediaobject>
<imageobject>
<imagedata fileref="./images/potential-commands.png"/>
</imageobject>
<textobject><phrase>potential commands</phrase></textobject>
</mediaobject>
</figure>
<simpara>If you observe carefully, there seem to be commands at two levels of granularity. The "Create LC Application" and "Update LC application" are coarse grained, whereas the others are a lot more focused in terms of their intent. One possible decomposition of the coarse grained commands can be as depicted here:</simpara>
<figure role="text-center">
<title>Decomposed commands</title>
<mediaobject>
<imageobject>
<imagedata fileref="./images/ui-patterns/old-new-commands.png"/>
</imageobject>
<textobject><phrase>old new commands</phrase></textobject>
</mediaobject>
</figure>
<simpara>In addition to just being more fine-grained than the commands in the previous iteration, the revised commands seem to better capture the user&#8217;s intent. This may feel like a minor change in semantics, but can have a huge impact on the way our solution is used by its ultimate end-users. The question then is whether we should <emphasis>always</emphasis> prefer fine-grained APIs over coarse grained ones. The answer can be a lot more nuanced. When designing APIs and experiences, we see two main styles being employed:</simpara>
<itemizedlist>
<listitem>
<simpara>CRUD-based</simpara>
</listitem>
<listitem>
<simpara>Task-based</simpara>
</listitem>
</itemizedlist>
<simpara>Let&#8217;s look at each of these in a bit more detail:</simpara>
<section xml:id="crud-based-apis">
<title>CRUD-based APIs</title>
<simpara>CRUD is an acronym used to refer to the four basic operations that can be performed on database applications: Create, Read, Update, and Delete. Many programming languages and protocols have their own equivalent of CRUD, often with slight variations in naming and intent. For example, SQL — a popular language for interacting with databases — calls the four functions Insert, Select, Update, and Delete. Similarly, the HTTP protocol has <literal>POST</literal>, <literal>GET</literal>, <literal>PUT</literal> and <literal>DELETE</literal> as verbs to represent these CRUD operations. This approach has got extended to our design of APIs as well. This has resulted in the proliferation of both CRUD-based APIs and user experiences. Take a look at the <literal>CreateLCApplicationCommand</literal> from Chapter 5:</simpara>
<programlisting language="java" linenumbering="numbered">import lombok.Data;

@Data
public class CreateLCApplicationCommand {

    private LCApplicationId id;

    private ClientId clientId;
    private Party applicant;
    private Party beneficiary;
    private AdvisingBank advisingBank;
    private LocalDate issueDate;
    private MonetaryAmount amount;
    private String merchandiseDescription;
}</programlisting>
<simpara>Along similar lines, it would not be uncommon to create a corresponding  <literal>UpdateLCApplicationCommand</literal> as depicted here:</simpara>
<programlisting language="java" linenumbering="numbered">import lombok.Data;

@Data
public class UpdateLCApplicationCommand {

    @TargetAggregateIdentifier
    private LCApplicationId id;

    private ClientId clientId;
    private Party applicant;
    private Party beneficiary;
    private AdvisingBank advisingBank;
    private LocalDate issueDate;
    private MonetaryAmount amount;
    private String merchandiseDescription;
}</programlisting>
<simpara>While this is very common and also very easy to grasp, it is not without problems. Here are some questions that taking this approach raises:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Are we allowed to change everything listed in the <literal>update</literal> command?</simpara>
</listitem>
<listitem>
<simpara>Assuming that everything can change, do they all change at the same time?</simpara>
</listitem>
<listitem>
<simpara>How do we know what exactly changed? Should we be doing a diff?</simpara>
</listitem>
<listitem>
<simpara>What if all the attributes mentioned above are not included in the <literal>update</literal> command?</simpara>
</listitem>
<listitem>
<simpara>What if we need to add attributes in future?</simpara>
</listitem>
<listitem>
<simpara>Is the business intent of what the user wanted to accomplish captured?</simpara>
</listitem>
</orderedlist>
<simpara>In a simple system, the answer to these questions may not matter that much. However, as system complexity increases, will this approach remain resilient to change? We feel that it merits taking a look at another approach called task-based APIs to be able to answer these questions.</simpara>
</section>
<section xml:id="task-based-apis">
<title>Task-based APIs</title>
<simpara>In a typical organization, individuals perform tasks relevant to their specialization. The bigger the organization, the higher the degree of specialization. This approach of segregating tasks according to one&#8217;s specialization makes sense, because it mitigates the possibility of stepping on each others' shoes, especially when getting complex pieces of work done. For example, in the LC application process, there is a need to establish the value/legality of the product while also determining the credit worthiness of the applicant. It makes sense that each of these tasks are usually performed by individuals in unrelated departments. It also follows that these tasks can be performed independently from the other.</simpara>
<simpara>In terms of a business process, if we have a single <literal>CreateLCApplicationCommand</literal> that precedes these operations, individuals in both departments firstly have to wait for the entire application to be filled out before either can commence their work. Secondly, if either piece of information is updated through a single <literal>UpdateLCApplicationCommand</literal>, it is unclear what changed. This can result in a spurious notification being sent to at least one department because of this lack of clarity in the process.</simpara>
<simpara>Since most work happens in the form of specific tasks, it can work to our advantage if our processes and by extension, our APIs mirror these behaviors.</simpara>
<simpara>Keeping this in mind, let&#8217;s re-examine our revised APIs for the LC application process:</simpara>
<informalfigure role="text-center">
<mediaobject>
<imageobject>
<imagedata fileref="./images/revised-commands-recap.png"/>
</imageobject>
<textobject><phrase>revised commands recap</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>While it may have appeared previously that we have simply converted our coarse-grained APIs to become more fine-grained, this in reality is a better representation of the tasks that the user intended to perform. So, in essence, task-based APIs are the decomposition of work in a manner that aligns more closely to the users' intents. With our new APIs, product validation can commence as soon as <literal>ChangeMerchandise</literal> happens. Also, it is unambiguously clear what the user did and what needs to happen in reaction to the user&#8217;s action. It then begs the question on whether we should employ task-based APIs all the time? Let&#8217;s look at the implications in more detail.</simpara>
</section>
<section xml:id="task-based-or-crud-based">
<title>Task-based or CRUD-based?</title>
<simpara>CRUD-based APIs seem to operate at the level of the aggregate. In our example, we have the LC aggregate. In the simplest case, this essentially translates to four operations aligned with each of the CRUD verbs. However, as we are seeing, even in our simplified version, the LC is becoming a fairly complex concept. Having to work with just four operations at the level of the LC is cognitively complex. With more requirements, this complexity will only continue to increase. For example, consider a situation where  the business expresses a need to capture a lot more information about the <literal>merchandise</literal>, where today, this is simply captured in the form of free-form text.</simpara>
<programlisting language="java" linenumbering="numbered">public class Merchandise {
    private MerchandiseId id;
    private Set&lt;Item&gt; items;
    private Packaging packaging;
    private boolean hazardous;
}

class Item {
    private ProductId productId;
    private int quantity;
    // ...
}

class Packaging {
    // ...
}</programlisting>
<simpara>In our current design, the implications of this change are far reaching for both the provider and the consumer(s). Let&#8217;s look at some of the consequences in more detail:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="11.1111*"/>
<colspec colname="col_2" colwidth="11.1111*"/>
<colspec colname="col_3" colwidth="11.1111*"/>
<colspec colname="col_4" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Characteristic</entry>
<entry align="center" valign="top">CRUD-based</entry>
<entry align="center" valign="top">Task-based</entry>
<entry align="left" valign="top">Commentary</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Usability</simpara></entry>
<entry align="center" valign="top"><simpara><phrase role="red"><inlinemediaobject>
<imageobject>
<imagedata fileref="./images/icons/thumbs-down.png"/>
</imageobject>
<textobject><phrase>thumbs down</phrase></textobject>
</inlinemediaobject></phrase></simpara></entry>
<entry align="center" valign="top"><simpara><phrase role="green"><inlinemediaobject>
<imageobject>
<imagedata fileref="./images/icons/thumbs-up.png"/>
</imageobject>
<textobject><phrase>thumbs up</phrase></textobject>
</inlinemediaobject></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Task-based interfaces tend to provide more fine-grained controls that capture user intent a lot more explicitly, making them naturally more usable&#8201;&#8212;&#8201;especially in cases where the domain is complex.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Reusability</simpara></entry>
<entry align="center" valign="top"><simpara><phrase role="red"><inlinemediaobject>
<imageobject>
<imagedata fileref="./images/icons/thumbs-down.png"/>
</imageobject>
<textobject><phrase>thumbs down</phrase></textobject>
</inlinemediaobject></phrase></simpara></entry>
<entry align="center" valign="top"><simpara><phrase role="green"><inlinemediaobject>
<imageobject>
<imagedata fileref="./images/icons/thumbs-up.png"/>
</imageobject>
<textobject><phrase>thumbs up</phrase></textobject>
</inlinemediaobject></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Task-based interfaces enable more complex features to be composed using simpler ones providing more flexibility to the consumers.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Scalability</simpara></entry>
<entry align="center" valign="top"><simpara><phrase role="red"><inlinemediaobject>
<imageobject>
<imagedata fileref="./images/icons/thumbs-down.png"/>
</imageobject>
<textobject><phrase>thumbs down</phrase></textobject>
</inlinemediaobject></phrase></simpara></entry>
<entry align="center" valign="top"><simpara><phrase role="green"><inlinemediaobject>
<imageobject>
<imagedata fileref="./images/icons/thumbs-up.png"/>
</imageobject>
<textobject><phrase>thumbs up</phrase></textobject>
</inlinemediaobject></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Task-based interfaces have an advantage because they can provide the ability to independently scale specific features. However, if the fine-grained task-based APIs are used almost all the time in unison, it may be required to re-examine whether the users' intents are accurately captured.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Security</simpara></entry>
<entry align="center" valign="top"><simpara><phrase role="red"><inlinemediaobject>
<imageobject>
<imagedata fileref="./images/icons/thumbs-down.png"/>
</imageobject>
<textobject><phrase>thumbs down</phrase></textobject>
</inlinemediaobject></phrase></simpara></entry>
<entry align="center" valign="top"><simpara><phrase role="green"><inlinemediaobject>
<imageobject>
<imagedata fileref="./images/icons/thumbs-up.png"/>
</imageobject>
<textobject><phrase>thumbs up</phrase></textobject>
</inlinemediaobject></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>For task-based interfaces, security is enhanced from the producer&#8217;s perspective by enabling application of the <emphasis>principle of least privilege<footnote><simpara><link xl:href="https://en.wikipedia.org/wiki/Principle_of_least_privilege">https://en.wikipedia.org/wiki/Principle_of_least_privilege</link></simpara></footnote></emphasis>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Latency</simpara></entry>
<entry align="center" valign="top"><simpara><phrase role="green"><inlinemediaobject>
<imageobject>
<imagedata fileref="./images/icons/thumbs-up.png"/>
</imageobject>
<textobject><phrase>thumbs up</phrase></textobject>
</inlinemediaobject></phrase></simpara></entry>
<entry align="center" valign="top"><simpara><phrase role="red"><inlinemediaobject>
<imageobject>
<imagedata fileref="./images/icons/thumbs-down.png"/>
</imageobject>
<textobject><phrase>thumbs down</phrase></textobject>
</inlinemediaobject></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Arguably, coarse-grained CRUD interfaces can enable consumers to achieve a lot more in less interactions, thereby providing low latency.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Management Overhead</simpara></entry>
<entry align="center" valign="top"><simpara><phrase role="green"><inlinemediaobject>
<imageobject>
<imagedata fileref="./images/icons/thumbs-up.png"/>
</imageobject>
<textobject><phrase>thumbs up</phrase></textobject>
</inlinemediaobject></phrase></simpara></entry>
<entry align="center" valign="top"><simpara><phrase role="red"><inlinemediaobject>
<imageobject>
<imagedata fileref="./images/icons/thumbs-down.png"/>
</imageobject>
<textobject><phrase>thumbs down</phrase></textobject>
</inlinemediaobject></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>For the provider, fine-grained interfaces require a lot more work managing a larger number of interfaces.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Complexity</simpara></entry>
<entry align="center" valign="top"><simpara><phrase role="gray"><inlinemediaobject>
<imageobject>
<imagedata fileref="./images/icons/question-circle.png"/>
</imageobject>
<textobject><phrase>question circle</phrase></textobject>
</inlinemediaobject></phrase></simpara></entry>
<entry align="center" valign="top"><simpara><phrase role="gray"><inlinemediaobject>
<imageobject>
<imagedata fileref="./images/icons/question-circle.png"/>
</imageobject>
<textobject><phrase>question circle</phrase></textobject>
</inlinemediaobject></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Complexity of the system as a whole is proportional to the number of features that need to be implemented. Irrespective of API style, this usually remains constant. However, spreading complexity relatively uniformly across multiple simpler interfaces can enable managing complexity a lot more effectively.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>As we can see, the decision between CRUD-based and task-based interfaces is nuanced. We are not suggesting that you should choose one over the other. Which style you use will depend on your specific requirements and context. In our experience, task-based interfaces treat user intents as first class citizens and perpetrate the spirit of DDD&#8217;s ubiquitous language very elegantly. In a lot of scenarios, providing both styles of APIs may work well for consumers, although it may add a certain amount of overhead to the interface provider.</simpara>
<simpara>This is a chapter on evolving the user interface, however, we have spent a lot of time discussing the backend APIs. However, the same principles apply when designing graphical user interfaces as well. Let&#8217;s revert back to creating the user interface for the LC application.</simpara>
</section>
</section>
<section xml:id="bootstrapping-the-ui">
<title>Bootstrapping the UI</title>
<simpara>We will simply be building on top of the LC application we created in Chapter 5: Implementing Domain Logic. For detailed instructions, refer to the section on Bootstrapping the Application. In addition, we will need to add the following dependencies to the <literal>dependencies</literal> section of the Maven <literal>pom.xml</literal> file in the root directory of the project:</simpara>
<programlisting language="xml" linenumbering="numbered">&lt;dependencies&gt;
    &lt;!--...--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.openjfx&lt;/groupId&gt;
        &lt;artifactId&gt;javafx-controls&lt;/artifactId&gt;
        &lt;version&gt;${javafx.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.openjfx&lt;/groupId&gt;
        &lt;artifactId&gt;javafx-graphics&lt;/artifactId&gt;
        &lt;version&gt;${javafx.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.openjfx&lt;/groupId&gt;
        &lt;artifactId&gt;javafx-fxml&lt;/artifactId&gt;
        &lt;version&gt;${javafx.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;de.saxsys&lt;/groupId&gt;
        &lt;artifactId&gt;mvvmfx&lt;/artifactId&gt;
        &lt;version&gt;${mvvmfx.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;de.saxsys&lt;/groupId&gt;
        &lt;artifactId&gt;mvvmfx-spring-boot&lt;/artifactId&gt;
        &lt;version&gt;${mvvmfx.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--...--&gt;
&lt;/dependencies&gt;</programlisting>
<simpara>To run UI tests, you will need to add the following dependencies:</simpara>
<programlisting language="xml" linenumbering="numbered">&lt;dependencies&gt;
    &lt;!--...--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.testfx&lt;/groupId&gt;
        &lt;artifactId&gt;testfx-junit5&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
        &lt;version&gt;${testfx-junit5.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.testfx&lt;/groupId&gt;
        &lt;artifactId&gt;openjfx-monocle&lt;/artifactId&gt;
        &lt;version&gt;${openjfx-monocle.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;de.saxsys&lt;/groupId&gt;
        &lt;artifactId&gt;mvvmfx-testing-utils&lt;/artifactId&gt;
        &lt;version&gt;${mvvmfx.version}&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;!--...--&gt;
&lt;/dependencies&gt;</programlisting>
<simpara>To be able to run the application from the command line, you will need to add the <literal>javafx-maven-plugin</literal> to the <literal>plugins</literal> section of your <literal>pom.xml</literal>, per the following:</simpara>
<programlisting language="xml" linenumbering="numbered">&lt;plugin&gt;
    &lt;groupId&gt;org.openjfx&lt;/groupId&gt;
    &lt;artifactId&gt;javafx-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;${javafx-maven-plugin.version}&lt;/version&gt;
    &lt;configuration&gt;
        &lt;mainClass&gt;com.premonition.lc.issuance.App&lt;/mainClass&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;</programlisting>
<simpara>To run the application from the command line, use:</simpara>
<programlisting language="bash" linenumbering="unnumbered">mvn javafx:run</programlisting>
<note>
<simpara>If you are using a JDK greater that version 1.8, the JavaFX libraries may not be bundled with the JDK itself. When running the application from your IDE, you will likely need to add the following:</simpara>
</note>
<programlisting language="bash" linenumbering="unnumbered">--module-path=&lt;path-to-javafx-sdk&gt;/lib/ \
   --add-modules=javafx.controls,javafx.graphics,javafx.fxml,javafx.media</programlisting>
<simpara>We are making use of the mvvmFX framework to assemble the UI. To make this work with spring boot, the application launcher looks as depicted here:</simpara>
<programlisting language="java" linenumbering="numbered">@SpringBootApplication
public class App extends MvvmfxSpringApplication { <co xml:id="CO1-1"/>

    public static void main(String[] args) {
        Application.launch(args);
    }

    @Override
    public void startMvvmfx(Stage stage) {
        stage.setTitle("LC Issuance");

        final Parent parent = FluentViewLoader
                .fxmlView(MainView.class)
                .load().getView();

        final Scene scene = new Scene(parent);
        stage.setScene(scene);
        stage.show();
    }
}</programlisting>
<calloutlist>
<callout arearefs="CO1-1">
<para>Note that we are required to extend from the mvvmFX framework class <literal>MvvmfxSpringApplication</literal>.</para>
</callout>
</calloutlist>
<note>
<simpara>Please refer to the ch06 directory of the accompanying source code repository for the complete example.</simpara>
</note>
</section>
<section xml:id="implementing-the-ui">
<title>Implementing the UI</title>
<simpara>When working with user interfaces, it is fairly customary to use one of these presentation patterns:</simpara>
<itemizedlist>
<listitem>
<simpara>Model-View-Controller (MVC)</simpara>
</listitem>
<listitem>
<simpara>Model-View-Presenter (MVP)</simpara>
</listitem>
<listitem>
<simpara>Model-View-ViewModel (MVVM)</simpara>
</listitem>
</itemizedlist>
<simpara>Each of these patterns enable us to produce code that is loosely coupled, testable and maintainable. Let&#8217;s briefly examine each of these in more detail here:</simpara>
<section xml:id="model-view-controller">
<title>Model View Controller</title>
<simpara>This is arguably the oldest, most popular when implementing user interfaces, given that it has been in existence since the early 1970s. The pattern breaks the app into three components:</simpara>
<figure role="text-center">
<title>MVC design pattern</title>
<mediaobject>
<imageobject>
<imagedata fileref="./images/ui-patterns/mvc.png"/>
</imageobject>
<textobject><phrase>mvc</phrase></textobject>
</mediaobject>
</figure>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Model</emphasis>: responsible to house the business logic and managing the state of the application.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">View</emphasis>: responsible for presenting data to the user.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Controller</emphasis>: responsible to act as a glue between the model and the view. It is also responsible for handling user interactions, data management, networking and validation.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>There are different schools of thought when it comes where concerns such as data fetching, persistence and related network interactions, etc. need to live. Some implementations (such as the active record<footnote><simpara><link xl:href="https://martinfowler.com/eaaCatalog/activeRecord.html">https://martinfowler.com/eaaCatalog/activeRecord.html</link></simpara></footnote> pattern) advocate making use of the model to house this logic. In other cases, the controller delegates to a repository<footnote><simpara><link xl:href="https://martinfowler.com/eaaCatalog/repository.html">https://martinfowler.com/eaaCatalog/repository.html</link></simpara></footnote> to interact with dumb models. Which variation you prefer to use comes down to personal tastes.</simpara>
</note>
</section>
<section xml:id="model-view-presenter">
<title>Model View Presenter</title>
<figure role="text-center">
<title>MVP design pattern</title>
<mediaobject>
<imageobject>
<imagedata fileref="./images/ui-patterns/mvp.png"/>
</imageobject>
<textobject><phrase>mvp</phrase></textobject>
</mediaobject>
</figure>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Model</emphasis>: responsible to house the business logic and managing the state of the application.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">View</emphasis>: responsible for presenting data to the user and notifying the presenter about user interactions.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Presenter</emphasis>: responsible for handling user interactions on behalf of the view. The presenter usually interacts with the view through an interface that the view implements. This allows for easier unit testing of the presenter independent of the view. The presenter interacts with the model for updates and read operations.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="model-view-view-model">
<title>Model View View-Model</title>
<figure role="text-center">
<title>MVVM design pattern</title>
<mediaobject>
<imageobject>
<imagedata fileref="./images/ui-patterns/mvvm.png"/>
</imageobject>
<textobject><phrase>mvvm</phrase></textobject>
</mediaobject>
</figure>
<itemizedlist>
<listitem>
<simpara>Model: responsible to house the business logic and managing the state of the application.</simpara>
</listitem>
<listitem>
<simpara>View: responsible for presenting data to the user and notifying the view-model about user interactions.</simpara>
</listitem>
<listitem>
<simpara>View-Model: responsible for handling user interactions on behalf of the view. The view-model interacts with the view using the observer pattern (typically one-way or two-way data binding to make it more convenient). The view-model interacts with the model for updates and read operations.</simpara>
</listitem>
</itemizedlist>
<simpara>Now that we understand the mechanics of each of these patterns, let&#8217;s look at which one to use.</simpara>
</section>
<section xml:id="which-one-mvc-mvp-or-mvvm">
<title>Which one: MVC, MVP or MVVM</title>
<simpara>The MVC pattern has been around for the longest time. The idea of separating concerns among collaborating model, view and controller objects is a sound one. However, beyond the definition of these objects, actual implementations seem to vary wildly&#8201;&#8212;&#8201;with the controller becoming overly complex in a lot of cases. In contrast, MVP and MVVM, while being derivatives of MVC, seem to bring out better separation of concerns between the collaborating objects. MVVM, in particular when coupled with data binding constructs, make for code that is much more readable, maintainable and testable. In this book, we make use of MVVM because it enables test-driven development which is a strong personal preference for us.</simpara>
</section>
</section>
<section xml:id="ui-implementation">
<title>UI Implementation</title>
<section xml:id="mvvm-primer">
<title>MVVM primer</title>
<simpara>Let&#8217;s consider the example of creating a new LC. To create a new LC, all we need is for the applicant to provide a friendly client reference. This is usually an easy to remember string of free text. A simple rendition of this UI is shown here:</simpara>
<figure role="text-center">
<title>Create LC screen</title>
<mediaobject>
<imageobject>
<imagedata fileref="./images/mvvm/create-lc-ui.png"/>
</imageobject>
<textobject><phrase>create lc ui</phrase></textobject>
</mediaobject>
</figure>
<section xml:id="declarative-view">
<title>Declarative view</title>
<simpara>When working with JavaFX, the view can be rendered using a declarative style in FXML format. Important excerpts from the <literal>CreateLCView.fxml</literal> file for the create LC view are shown here:</simpara>
<programlisting language="xml" linenumbering="numbered">&lt;?import javafx.scene.layout.Pane?&gt;
&lt;?import javafx.scene.control.Button?&gt;
&lt;?import javafx.scene.control.TextField?&gt;

&lt;Pane id="create-lc"  xmlns="http://javafx.com/javafx/16"
                      xmlns:fx="http://javafx.com/fxml/1"
      fx:controller="com.premonition.lc.issuance.ui.views.CreateLCView"&gt; <co xml:id="CO2-1"/>
    ...

    &lt;TextField id="client-reference"
               fx:id="clientReference"/&gt;                                 <co xml:id="CO2-2"/>

    &lt;Button id="create-button"
            fx:id="createButton"
            text="Create"
            onAction="#create"/&gt;                                         <co xml:id="CO2-3"/>
    ...
&lt;/Pane&gt;</programlisting>
<calloutlist>
<callout arearefs="CO2-1">
<para>The <literal>CreateLCView</literal> class acts as the view delegate for the FXML view and is assigned using the <literal>fx:controller</literal> attribute of the root element (<literal>javafx.scene.layout.Pane</literal> in this case).</para>
</callout>
<callout arearefs="CO2-2">
<para>In order to reference <literal>client-reference</literal> textbox in the view delegate, we use the <literal>fx:id</literal> annotation&#8201;&#8212;&#8201;<literal>clientReference</literal> in this case.</para>
</callout>
<callout arearefs="CO2-3">
<para>Similarly, the <literal>create-button</literal> is referenced using <literal>fx:id=createButton</literal> in the view delegate. Furthermore, the <literal>create</literal> method in the view delegate is assigned to handle the default action (the button press event for <literal>javafx.scene.control.Button</literal>).</para>
</callout>
</calloutlist>
</section>
<section xml:id="view-delegate">
<title>View delegate</title>
<simpara>Next, let&#8217;s look at the structure of the view delegate <literal>com.premonition.lc.issuance.ui.views.CreateLCView</literal>:</simpara>
<programlisting language="java" linenumbering="numbered">import javafx.fxml.FXML;
//...
public class CreateLCView {                     <co xml:id="CO3-1"/>

    @FXML
    private TextField clientReference;          <co xml:id="CO3-2"/>
    @FXML
    private Button createButton;                <co xml:id="CO3-3"/>

    public void create(ActionEvent event) {     <co xml:id="CO3-4"/>
        // Handle button press logic here
    }

    // Other parts omitted for brevity...
}</programlisting>
<calloutlist>
<callout arearefs="CO3-1">
<para>The view delegate class for the <literal>CreateLCView.fxml</literal> view.</para>
</callout>
<callout arearefs="CO3-2">
<para>The Java binding for the <literal>clientReference</literal> textbox in the view. The name of the member needs to match exactly with the value of the <literal>fx:id</literal> attribute in the view. Further, it needs to be annotated with the <literal>@javafx.fxml.FXML</literal> annotation. The use of the <literal>@FXML</literal> annotation is optional if the member in the view delegate is <literal>public</literal> and matches the name in the view.</para>
</callout>
<callout arearefs="CO3-3">
<para>Similarly, the <literal>createButton</literal> is bound to the corresponding button widget in the view.</para>
</callout>
<callout arearefs="CO3-4">
<para>The method for the action handler when the <literal>createButton</literal> is pressed.</para>
</callout>
</calloutlist>
</section>
<section xml:id="view-model">
<title>View-Model</title>
<simpara>The view-model class <literal>CreateLCViewModel for the `CreateLCView</literal> is shown here:</simpara>
<programlisting language="java" linenumbering="numbered">import javafx.beans.property.StringProperty;
import de.saxsys.mvvmfx.ViewModel;

public class CreateLCViewModel implements ViewModel {      <co xml:id="CO4-1"/>

    private final StringProperty clientReference;          <co xml:id="CO4-2"/>

    public CreateLCViewModel() {
        this.clientReference = new SimpleStringProperty(); <co xml:id="CO4-3"/>
    }

    public StringProperty clientReferenceProperty() {      <co xml:id="CO4-4"/>
        return clientReference;
    }

    public String getClientReference() {
        return clientReference.get();
    }

    public void setClientReference(String clientReference) {
        this.clientReference.set(clientReference);
    }

    // Other getters and setters omitted for brevity
}</programlisting>
<calloutlist>
<callout arearefs="CO4-1">
<para>The view-model class for the <literal>CreateLCView</literal>. Note that we are required to implement the <literal>de.saxsys.mvvmfx.ViewModel</literal> interface provided by the mvvmFX framework.</para>
</callout>
<callout arearefs="CO4-2">
<para>We are initializing the <literal>clientReference</literal> property using the <literal>SimpleStringProperty</literal> provided by JavaFX. There are several other property classes to define more complex types. Please refer to the JavaFX documentation for more details.</para>
</callout>
<callout arearefs="CO4-3">
<para>The value of the <literal>clientReference</literal> in the view-model. We will look at how to associate this with value of the <literal>clientReference</literal> textbox in the view shortly. Note that we are using the <literal>StringProperty</literal> provided by <literal>JavaFX</literal>, which provides access to the underlying <literal>String</literal> value of the client reference.</para>
</callout>
<callout arearefs="CO4-4">
<para><literal>JavaFX</literal> beans are required to create a special accessor for the property itself in addition to the standard getter and setter for the underlying value.</para>
</callout>
</calloutlist>
</section>
<section xml:id="binding-the-view-to-the-view-model">
<title>Binding the view to the view-model</title>
<simpara>Next, let&#8217;s look at how to associate the view to the view-model:</simpara>
<programlisting language="java" linenumbering="numbered">import de.saxsys.mvvmfx.Initialize;
import de.saxsys.mvvmfx.FxmlView;
import de.saxsys.mvvmfx.InjectViewModel;
//...
public class CreateLCView implements FxmlView&lt;CreateLCViewModel&gt; {   <co xml:id="CO5-1"/>

    @FXML
    private TextField clientReference;
    @FXML
    private Button createButton;

    @InjectViewModel
    private CreateLCViewModel viewModel;                             <co xml:id="CO5-2"/>

    @Initialize
    private void initialize() {                                      <co xml:id="CO5-3"/>
        clientReference.textProperty()
            .bindBidirectional(viewModel.clientReferenceProperty()); <co xml:id="CO5-4"/>
        createButton.disableProperty()
            .bind(viewModel.createDisabledProperty());               <co xml:id="CO5-5"/>
    }

    // Other parts omitted for brevity...
}</programlisting>
<calloutlist>
<callout arearefs="CO5-1">
<para>The mvvmFX framework requires that the view delegate implement the <literal>FXMLView&lt;? extends ViewModelType&gt;</literal>. In this case, the view-model type is <literal>CreateLCViewModel</literal>. The mvvmFX framework supports other view types as well. Please refer to the framework documentation for more details.</para>
</callout>
<callout arearefs="CO5-2">
<para>The framework provides a <literal>@de.saxsys.mvvmfx.InjectViewModel</literal> annotation to allow dependency injecting the view-model into the view delegate.</para>
</callout>
<callout arearefs="CO5-3">
<para>The framework will invoke all methods annotated with the <literal>@de.saxsys.mvvmfx.Initialize</literal> annotation during the initialization process. The annotation can be omitted if the method is named <literal>initialize</literal> and is declared <literal>public</literal>. Please refer to the framework documentation for more details.</para>
</callout>
<callout arearefs="CO5-4">
<para>We have now bound the text property of the <literal>clientReference</literal> textbox in the view delegate to the corresponding property in the view-model. Note that this is a <emphasis role="strong">bidirectional</emphasis> binding, which means that the value in the view and the view model are kept in sync if it changes on either side.</para>
</callout>
<callout arearefs="CO5-5">
<para>This is another variation of binding in action, where we are making use of a unidirectional binding. Here, we are binding the disabled property of the <literal>create</literal> button to the corresponding property on the view-model. We will look at why we need to do this shortly.</para>
</callout>
</calloutlist>
</section>
<section xml:id="enforcing-business-validations-in-the-ui">
<title>Enforcing business validations in the UI</title>
<simpara>We have a business validation that the client reference for an LC needs to be at least 4 characters in length. This will be enforced on the back-end. However, to provide a richer user experience, we will also enforce this validation on the UI.</simpara>
<warning>
<simpara>This may feel contrary to the notion of centralizing business validations on the back-end. While this may be a noble attempt at implementing the DRY (Don&#8217;t Repeat Yourself) principle, in reality, it poses a lot of practical problems. Distributed systems expert&#8201;&#8212;&#8201;Udi Dahan has a very interesting take on why this may not be such a virtuous thing to pursue<footnote><simpara><link xl:href="https://vimeo.com/131757759">https://vimeo.com/131757759</link></simpara></footnote>. Ted Neward also talks about this in his blog titled <emphasis>The Fallacies of Enterprise Computing</emphasis><footnote><simpara><link xl:href="http://blogs.tedneward.com/post/enterprise-computing-fallacies/">http://blogs.tedneward.com/post/enterprise-computing-fallacies/</link></simpara></footnote>.</simpara>
</warning>
<simpara>The advantage of using MVVM is that this logic is easily testable in a simple unit test of the view-model. Let&#8217;s see this in action test-drive this now:</simpara>
<programlisting language="java" linenumbering="numbered">class CreateLCViewModelTests {

    private CreateLCViewModel viewModel;

    @BeforeEach
    void before() {
        int clientReferenceMinLength = 4;
        viewModel = new CreateLCViewModel(clientReferenceMinLength);
    }

    @Test
    void shouldNotEnableCreateByDefault() {
        assertThat(viewModel.getCreateDisabled()).isTrue();
    }

    @Test
    void shouldNotEnableCreateIfClientReferenceLesserThanMinimumLength() {
        viewModel.setClientReference("123");
        assertThat(viewModel.getCreateDisabled()).isTrue();
    }

    @Test
    void shouldEnableCreateIfClientReferenceEqualToMinimumLength() {
        viewModel.setClientReference("1234");
        assertThat(viewModel.getCreateDisabled()).isFalse();
    }

    @Test
    void shouldEnableCreateIfClientReferenceGreaterThanMinimumLength() {
        viewModel.setClientReference("12345");
        assertThat(viewModel.getCreateDisabled()).isFalse();
    }
}</programlisting>
<simpara>Now, let&#8217;s look at the implementation for this functionality in the view-model:</simpara>
<programlisting language="java" linenumbering="numbered">public class CreateLCViewModel implements ViewModel {

    //...
    private final StringProperty clientReference;
    private final BooleanProperty createDisabled;                    <co xml:id="CO6-1"/>

    public CreateLCViewModel(int clientReferenceMinLength) {         <co xml:id="CO6-2"/>
        this.clientReference = new SimpleStringProperty();
        this.createDisabled = new SimpleBooleanProperty();
        this.createDisabled
            .bind(this.clientReference.length()
                    .lessThan(clientReferenceMinLength));            <co xml:id="CO6-3"/>
    }

    //...
}

public class CreateLCView implements FxmlView&lt;CreateLCViewModel&gt; {

    //...
    @Initialize
    public void initialize() {
        createButton.disableProperty()
            .bind(viewModel.createDisabledProperty());               <co xml:id="CO6-4"/>
        clientReference.textProperty()
            .bindBidirectional(viewModel.clientReferenceProperty());
    }
    //...
}</programlisting>
<calloutlist>
<callout arearefs="CO6-1">
<para>We declare a <literal>createDisabled</literal> property in the view-model to manage when the create button should be disabled.</para>
</callout>
<callout arearefs="CO6-2">
<para>The minimum length for a valid client reference is injected into the view-model. It is conceivable that this value will be provided as part of external configuration, or possibly from the back-end.</para>
</callout>
<callout arearefs="CO6-3">
<para>We create a binding expression to match the business requirement.</para>
</callout>
<callout arearefs="CO6-4">
<para>We bind the view-model property to the disabled property of the create button in the view delegate.</para>
</callout>
</calloutlist>
<simpara>Let&#8217;s also look at how to write an end-to-end, headless UI test as shown here:</simpara>
<programlisting language="java" linenumbering="numbered">@UITest
public class CreateLCViewTests {                                  <co xml:id="CO7-1"/>

    @Autowired
    private ApplicationContext context;

    @Init
    public void init() {
        MvvmFX.setCustomDependencyInjector(context::getBean);     <co xml:id="CO7-2"/>
    }

    @Start
    public void start(Stage stage) {                              <co xml:id="CO7-3"/>
        final Parent parent = FluentViewLoader
                .fxmlView(CreateLCView.class)
                .load().getView();
        stage.setScene(new Scene(parent));
        stage.show();
    }

    @Test
    void blankClientReference(FxRobot robot) {
        robot.lookup("#client-reference")                         <co xml:id="CO7-4"/>
            .queryAs(TextField.class)
            .setText("");

        verifyThat("#create-button", NodeMatchers.isDisabled());  <co xml:id="CO7-5"/>
    }

    @Test
    void validClientReference(FxRobot robot) {
        robot.lookup("#client-reference")
            .queryAs(TextField.class)
            .setText("Test");

        verifyThat("#create-button", NodeMatchers.isEnabled());   <co xml:id="CO7-6"/>
    }
}</programlisting>
<calloutlist>
<callout arearefs="CO7-1">
<para>We have written a convenience <literal>@UITest</literal> extension to combine spring framework and TestFX testing. Please refer to the accompanying source code with the book for more details.</para>
</callout>
<callout arearefs="CO7-2">
<para>We set up the spring context to act as the dependency injection provider for the mvvmFX framework and its injection annotations (for example, <literal>@InjectViewModel</literal>) to work.</para>
</callout>
<callout arearefs="CO7-3">
<para>We are using the <literal>@Start</literal> annotation provided by the TestFX framework to launch the UI.</para>
</callout>
<callout arearefs="CO7-4">
<para>The TestFX framework injects an instance of the <literal>FxRobot</literal> UI helper, which we can use to access UI elements.</para>
</callout>
<callout arearefs="CO7-5 CO7-6">
<para>We are using the The TestFX framework provided convenience matchers for test assertions.</para>
</callout>
</calloutlist>
<simpara>Now, when we run the application, we can see that the create button is enabled when a valid client reference is entered:</simpara>
<figure role="text-center">
<title>The Create button is enabled with a valid client reference</title>
<mediaobject>
<imageobject>
<imagedata fileref="./images/mvvm/valid-client-reference-input.png"/>
</imageobject>
<textobject><phrase>valid client reference input</phrase></textobject>
</mediaobject>
</figure>
</section>
</section>
<section xml:id="a-crud-based-ui-example">
<title>A CRUD-based UI example</title>

</section>
<section xml:id="a-task-based-ui-example">
<title>A task-based UI example</title>

</section>
</section>
<section xml:id="the-bff-pattern">
<title>The BFF Pattern</title>

</section>
<section xml:id="summary">
<title>Summary</title>

</section>
<section xml:id="questions">
<title>Questions</title>

</section>
<section xml:id="further-reading">
<title>Further reading</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Title</entry>
<entry align="left" valign="top">Author</entry>
<entry align="left" valign="top">Location</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>TODO</simpara></entry>
<entry align="left" valign="top"><simpara>TODO</simpara></entry>
<entry align="left" valign="top"><simpara>TODO</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
</article>