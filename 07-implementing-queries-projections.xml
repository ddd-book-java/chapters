<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc maxdepth="3"?>
<?asciidoc-numbered?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Implementing Queries and Projections (10 pages)</title>
<date>2021-08-28</date>
</info>
<section xml:id="implementing-queries-and-projections-10-pages" role="text-justify">
<title>Implementing Queries and Projections (10 pages)</title>
<blockquote>
<attribution>
Anonymous
</attribution>
<simpara>The best view comes after the hardest climb.</simpara>
</blockquote>
<simpara>In the section on <link linkend="command-query-responsibility-segregation-cqrs">CQRS</link>, we described how DDD and CQRS complement each other and how the query side (read models) can be used to create one or more representations of the underlying data. In this chapter, we will dive deeper into how we can construct read optimized representations of the data by listening to domain events. We will also look at persistence options for these read models.</simpara>
<simpara>When working with query models, we construct models by listening to events as they happen. We will examine how to deal with situations where:</simpara>
<itemizedlist>
<listitem>
<simpara>New requirements evolve over a period of time requiring us to build new query models.</simpara>
</listitem>
<listitem>
<simpara>We discover a bug in our query model which requires us to recreate the model from scratch.</simpara>
</listitem>
</itemizedlist>
<section xml:id="technical-requirements">
<title>Technical requirements</title>
<itemizedlist>
<listitem>
<simpara>JDK 1.8+ (We have used Java 16 to compile sample sources)</simpara>
</listitem>
<listitem>
<simpara>JavaFX SDK 16 and SceneBuilder</simpara>
</listitem>
<listitem>
<simpara>Spring Boot 2.4.x</simpara>
</listitem>
<listitem>
<simpara>mvvmFX 1.8 (<link xl:href="https://sialcasa.github.io/mvvmFX/">https://sialcasa.github.io/mvvmFX/</link>)</simpara>
</listitem>
<listitem>
<simpara>JUnit 5.7.x (Included with spring boot)</simpara>
</listitem>
<listitem>
<simpara>TestFX (for UI testing)</simpara>
</listitem>
<listitem>
<simpara>OpenJFX Monocle (for headless UI testing)</simpara>
</listitem>
<listitem>
<simpara>Project Lombok (To reduce verbosity)</simpara>
</listitem>
<listitem>
<simpara>Axon server to act as an event store</simpara>
</listitem>
<listitem>
<simpara>Maven 3.x</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="continuing-our-design-journey">
<title>Continuing our design journey</title>
<simpara>In <link linkend="_domain_analysis_and_modeling">Chapter 4 - Domain analysis and modeling</link>, we discussed eventstorming as a lightweight method to clarify business flows. As a reminder, this is the output produced from our eventstorming session:</simpara>
<figure role="text-center">
<title>Recap of eventstorming session</title>
<mediaobject>
<imageobject>
<imagedata fileref="./images/event-storming/05-query-models.png"/>
</imageobject>
<textobject><phrase>05 query models</phrase></textobject>
</mediaobject>
</figure>
<simpara>As mentioned previously, we are making use of the CQRS architecture pattern to create the solution. For a detailed explanation on why this is a sound method to employ, please refer to the <link linkend="_why_cqrs">Why CQRS</link> section in <link linkend="_implementing_domain_logic">Chapter 5 - Implementing Domain Logic</link>. In the diagram above, the <emphasis role="strong">green</emphasis> stickies represent <emphasis role="strong">read/query models</emphasis>. These query models are required when validating a command (for example: list of valid product identifiers when processing the <literal>ValidateProduct</literal> command) or if information is simply required to be presented to the user (for example: a list of LCs created by an applicant).</simpara>
</section>
<section xml:id="applying-cqrs">
<title>Applying CQRS</title>
<simpara>As covered in chapter 3, the CQRS pattern separates write (operations that mutate state) and read (operations that answer questions) operations into distinct (logical and/or physical) components from an architecture perspective. Letâ€™s look at what it means to apply CQRS in practical terms.</simpara>
<section xml:id="why-cqrs">
<title>Why CQRS?</title>
<simpara>As we have seen previously, in a CQRS-based system, there are distinct sets of models:</simpara>
<itemizedlist>
<listitem>
<simpara>One for the command side</simpara>
</listitem>
<listitem>
<simpara>One or more for the query side</simpara>
</listitem>
</itemizedlist>
<simpara>In chapter 5, we saw how to publish events when a command is successfully processed. Now, let&#8217;s look at how we can construct a query model by listening to these domain events. Logically, this will look something like how it is depicted here:</simpara>
<figure role="text-center">
<title>CQRS application&#8201;&#8212;&#8201;query side</title>
<mediaobject>
<imageobject>
<imagedata fileref="./images/cqrs/cqrs-query-side.png"/>
</imageobject>
<textobject><phrase>cqrs query side</phrase></textobject>
</mediaobject>
</figure>
<note>
<simpara>Please refer to the section on <link linkend="_implementing_the_command_side">implementing the command side</link> in Chapter 5 for a detailed explanation of how the command side is implemented.</simpara>
</note>
<simpara>The high level sequence on the query side is described here:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>An event listening component listens to these domain events published on the event bus.</simpara>
</listitem>
<listitem>
<simpara>Constructs a purpose-built query model to satisfy a specific query use case.</simpara>
</listitem>
<listitem>
<simpara>This query model is persisted in a datastore optimized for read operations.</simpara>
</listitem>
<listitem>
<simpara>This query model is then exposed in the form of an API.</simpara>
</listitem>
</orderedlist>
<note>
<simpara>Note how there can exist more than one query side component to handle respective scenarios.</simpara>
</note>
<simpara>Let&#8217;s implement each of these steps to see how this works for our LC issuance application.</simpara>
</section>
<section xml:id="tooling-choices">
<title>Tooling choices</title>

</section>
</section>
<section xml:id="implementing-the-query-side">
<title>Implementing the query side</title>
<section xml:id="identifying-queries">
<title>Identifying queries</title>
<simpara>From the eventstorming session, we have the following queries to start with:</simpara>
<figure role="text-center">
<title>Identified queries</title>
<mediaobject>
<imageobject>
<imagedata fileref="./images/potential-commands.png"/>
</imageobject>
<textobject><phrase>potential commands</phrase></textobject>
</mediaobject>
</figure>
<simpara>These query models are an absolute necessity to implement basic functionality dictated by business requirements. But it is possible and very likely that we will need additional query models as the system requirements evolve. We will enhance our application to support these queries as and when the need arises.</simpara>
</section>
</section>
<section xml:id="consume-events">
<title>Consume events</title>
<simpara>As seen in chapter 5, when starting a new LC application, the importer sends a <literal>StartNewLCApplicationCommand</literal>, which results in the <literal>LCApplicationStartedEvent</literal> being emitted as shown here:</simpara>
<programlisting language="java" linenumbering="numbered">class LCApplication {
    //..
    @CommandHandler
    public LCApplication(StartNewLCApplicationCommand command) {
        // Validation code omitted for brevity
        // Refer to chapter 5 for details.
        AggregateLifecycle.apply(new LCApplicationStartedEvent(command.getId(),
                command.getApplicantId(), command.getClientReference()));
    }
    //..
}</programlisting>
<simpara>Let&#8217;s write an event processing component which will listen to this event and construct a query model. When working with the Axon framework, we have a convenient way to do this by annotating the event listening method with the <literal>@EventHandler</literal> annotation.</simpara>
<programlisting language="java" linenumbering="numbered">import org.axonframework.eventhandling.EventHandler;

class LCApplicationStartedEventHandler {

    @EventHandler                                     <co xml:id="CO1-1"/>
    public void on(LCApplicationStartedEvent event) { <co xml:id="CO1-2"/>
        // Construct a query model here
    }
}</programlisting>
<calloutlist>
<callout arearefs="CO1-1">
<para>To make any method an event listener, we annotate it with the <literal>@EventHandler</literal> annotation.</para>
</callout>
<callout arearefs="CO1-2">
<para>The handler method needs to specify the event that we intend to listen to. There are other arguments that are supported for event handlers. Please refer to the Axon framework documentation for more information.</para>
</callout>
</calloutlist>
<note>
<simpara>The <literal>@EventHandler</literal> annotation should not be confused with the <literal>@EventSourcingHandler</literal> annotation which we looked at in chapter 5. The <literal>@EventSourcingHandler</literal> annotation is used to replay events and restore aggregate state when loading event-sourced aggregates on the command side, whereas the <literal>@EventHandler</literal> annotation is used to listen to events outside the context of the aggregate. In other words, the <literal>@EventSourcingHandler</literal> annotation is used exclusively within aggregates, whereas the <literal>@EventHandler</literal> annotation can be used anywhere there is a need to consume domain events. In this case, we are using it to construct a query model.</simpara>
</note>
</section>
<section xml:id="persisting-a-query-read-model">
<title>Persisting a query (read) model</title>

</section>
<section xml:id="creating-additional-query-read-models">
<title>Creating additional query (read) models</title>

</section>
<section xml:id="historic-event-replays">
<title>Historic event replays</title>
<section xml:id="the-need-for-replays">
<title>The need for replays</title>

</section>
<section xml:id="types-of-replays">
<title>Types of replays</title>
<section xml:id="full-event-replays">
<title>Full event replays</title>

</section>
<section xml:id="partial-event-replays">
<title>Partial event replays</title>

</section>
<section xml:id="adhoc-event-replays">
<title>Adhoc event replays</title>

</section>
</section>
<section xml:id="event-replay-considerations">
<title>Event replay considerations</title>
<section xml:id="application-availability">
<title>Application availability</title>

</section>
<section xml:id="optimization-techniques">
<title>Optimization techniques</title>

</section>
</section>
</section>
</section>
</article>